function [ dz ] = model(t, z)
%% This function calculates a vector of 
%      derivatives
%  t represents current time 
%  z is 9 demetial vector which represents 
%      state of the system

global omega_s r T_r E_r T_rd T_rq T_J U ...
       theta_net;    

%% Variables of equation 
    theta = z(1); s = z(2); Q = z(3);
    psi_d = z(4); psi_q = z(5); psi_r = z(6); 
    psi_rd = z(7); psi_rq = z(8); 
    mu = cutMu(z(9));

%% Currents and EMF
    I = solveFluxLincageEquations(psi_d, ...
        psi_q, psi_r, psi_rd, psi_rq);
    i_d  = I(1); i_q  = I(2); E_q  = I(3); 
    E_rd = I(4); E_rq = I(5);
%% Voltages
    u_d = - U * sin(theta + theta_net); 
    u_q = U * cos(theta + theta_net);
%% Torque which generated by turbine
    M_T = calculateTurbineTorque(Q, mu, s);
%% Vector of derivatives
dz = [  ...
omega_s * s; ... 
1 / T_J * (M_T - (psi_d*i_q - psi_q*i_d)); ... 
findWaterFlow(Q, mu); ... 
- omega_s * ((s+1)*psi_q + r*i_d + u_d); ... 
- omega_s * ( - (s+1)*psi_d + r*i_q + u_q); ... 
1 / T_r * (E_r - E_q); ... 
- 1 / T_rd * E_rq; ... 
1 / T_rq * E_rd; ... 
findTurbineControl(s, mu)]; 
end

function [I] = solveFluxLincageEquations(...
    p_d, p_q, p_r, p_rd, p_rq)
%% This function finds currents and EMF in 
%  system parameters p_d, p_q, p_r, p_rd, 
%  p_rq are fluxes
%  Matrix A is set in function named 
%  simulateModel
global A;
    Psi = [p_d; p_q; p_r; p_rd; p_rq];
    I = mldivide(A, Psi);
end

function [M] = calculateTurbineTorque(...
    Q, mu, s) 
%% This function calculates torque of 
%  turbine
%  parameter Q  is flow of water
%  parameter mu is turbine control
%  parameter s  is slip
global k mu_nom omega_s C;
alpha = (mu_nom + mu)^2;
M = k*Q^3/(alpha * C^2 * omega_s^2 * (s + 1));
end

function [dq] = findWaterFlow(Q, mu)
%% This function finds the water flow
%  through the turbine
% parameter Q  is current water flow
% parameter mu is current turbine control
global C S l ro p_u p_l mu_nom;
alpha = (mu_nom + mu)^2;
dq = S/l/ro*(p_u - p_l - Q^2/(alpha * C^2));
end

function [dmu] = findTurbineControl(s, mu)
%% This function finds turbine control
%  parameter s  is frequency deviation
%  parameter mu is current turbine control
global CK T_0 mu_min mu_max  ...
       senser_sense use_control omega_s;

if (use_control > 0)
    ss = sign(s) * (abs(s*omega_s)...
     - senser_sense)/omega_s;
    dmu =  (- ss - mu) / T_0;
    if ((mu >= mu_max && dmu > 0) ...
        || (mu <= mu_min && dmu < 0))
        dmu = 0;
    end;
else
    dmu = 0;
end

dmu = dmu * CK;
end

function [mu] = cutMu(s) 
global mu_min mu_max;
    mu = s;
    
    if (s >= mu_max)
        mu = mu_max;
    end;

    if (s <= mu_min)
        mu = mu_min;
    end;
end