function [jac] = JacobianFunction(theta)

global r E_r U x_d x_q x_ad x_r x_rd ... 
       x_aq p_u p_l C mu_nom theta_net; 
   
Q = C*mu_nom*sqrt(p_u-p_l);

i_d = x_q ...
    /(r^2+x_d*x_q)*(r/x_q*U ...
    	* sin(theta_net+theta) ...
    	+ U * cos(theta_net+theta) - E_r);
i_q =  r ...
    /(r^2+x_d*x_q)*(x_d/r*U ...
    	* sin(theta_net+theta) ...
    	+ U * cos(theta_net+theta) + E_r);

psi_d  = x_d * i_d + E_r;
psi_q  = x_q * i_q;
psi_r  = x_ad^2/x_r*i_d + E_r;
psi_rd = x_ad^2/x_rd*i_d + x_ad/x_rd*E_r;
psi_rq = x_aq^2/x_rd*i_q;

point = [theta, 0, Q, psi_d, psi_q, ...
    psi_r, psi_rd, psi_rq, 0];
f_J = @(x) model(0, x);

[~,~,~,~,~,~,jac] = lsqnonlin(f_J, point, ...
	[], [], ...
    optimset('MaxIter', 900000, ...
             'MaxFunEvals', 900000));

jac = jac + zeros(9);
end